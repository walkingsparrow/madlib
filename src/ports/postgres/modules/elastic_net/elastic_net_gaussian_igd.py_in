
import plpy
from utilities.utilities import __unique_string
from utilities.control import IterationController
from elastic_net_utils import IterationControllerNoTableDrop
from elastic_net_utils import __compute_means
from convex.utils_regularization import __utils_restore_linear_coef_scales
from elastic_net_utils import __normalize_data
from elastic_net_utils import __tbl_dimension_rownum
from elastic_net_utils import __elastic_net_validate_args
from elastic_net_utils import __compute_log_likelihood

## ========================================================================

def __igd_params_parser(optimizer_params):
    """
    Parse IGD parameters.
    """
    allowed_params = set(["stepsize"])
    name_value = dict()
    # default values
    name_value["stepsize"] = 0.01 

    if optimizer_params is None:
        return name_value
    
    for s in optimizer_params:
        items = s.split("=")
        if (len(items) != 2):
            plpy.error("Optimizer parameter list has incorrect format!")
        param_name = items[0].strip()
        param_value = items[1].strip()

        if param_name not in allowed_params:
            plpy.error("{0} is not a valid parameter name for the IGD optimizer.".format(param_name))

        if param_name == "stepsize":
            name_value["stepsize"] = float(param_value)

    # validate the parameters
    if name_value["stepsize"] <= 0:
        plpy.error("Elastic Net error: step size must be positive!")

    return name_value

## ========================================================================

def __igd_create_tbl_args(**args):
    """
    create the temporary schema and argument table used in IGD iterations
    """
    (xmean_str, ymean) = __compute_means(args["tbl_used"], args["col_ind_var_new"],
                                         args["col_dep_var"], args["dimension"],
                                         args["normalization"])
    
    effective_lambda = args["lambda_value"] # * args["row_num"]
    plpy.execute("""
                 drop table if exists {tbl_igd_args};
                 create temp table {tbl_igd_args} (
                    {dimension_name}       integer,
                    {stepsize_name}        double precision,
                    {lambda_name}          double precision,
                    {alpha_name}           double precision,
                    {total_rows_name}      integer,
                    {max_iter_name}        integer,
                    {tolerance_name}       double precision,
                    {xmean_name}           double precision[],
                    {ymean_name}           double precision
                 );
                 """.format(**args))
    plpy.execute("""
                 insert into {tbl_igd_args} values
                    ({dimension}, {stepsize}, {effective_lambda}, {alpha},
                     {row_num}, {max_iter}, {tolerance}, {xmean_str}, {ymean})
                 """.format(effective_lambda = effective_lambda,
                            xmean_str = xmean_str, ymean = ymean,
                            **args))

    return None
    
## ========================================================================

def __igd_construct_dict(schema_madlib, tbl_source, col_ind_var, col_dep_var,
                         tbl_result, dimension, row_num, lambda_value, alpha,
                         normalization, max_iter, tolerance, optimizer_params_dict):
    """
    Construct the dict used by a series of SQL queries in IGD optimizer.
    """
    args = dict(schema_madlib = schema_madlib, tbl_source = tbl_source,
                tbl_data = tbl_source, # argument name used in normalization
                col_ind_var = col_ind_var, col_dep_var = col_dep_var,
                col_ind_var_norm_new = __unique_string(), # for normalization usage
                col_ind_var_tmp = __unique_string(),
                tbl_result = tbl_result,
                lambda_value = lambda_value, alpha = alpha,
                dimension = dimension, row_num = row_num,
                max_iter = max_iter, tolerance = tolerance,
                normalization = normalization)
    
    # Add the optimizer parameters
    args.update(optimizer_params_dict)

    # Table names useful when normalizing the original data
    # Note: in order to be consistent with the calling convention
    # of the normalization functions, multiple elements of the dict
    # actually have the same value. This is a price that one has to pay
    # if he wants to save typing argument names by using **args as the
    # function argument.
    tbl_ind_scales = __unique_string()
    tbl_dep_scale = __unique_string()
    tbl_data_scaled = __unique_string()
    args.update(tbl_dep_scale = tbl_dep_scale,
                tbl_ind_scales = tbl_ind_scales,
                tbl_data_scaled = tbl_data_scaled)

    # Table names used in IGD iterations
    args.update(tbl_igd_state = __unique_string(),
                tbl_igd_args = __unique_string())

    # Table name used as the intermediate storage before scale restores
    args.update(tbl_inter_result = __unique_string())

    # more, for args table
    args["dimension_name"] = __unique_string()
    args["stepsize_name"] = __unique_string()
    args["lambda_name"] = __unique_string()
    args["alpha_name"] = __unique_string()
    args["total_rows_name"] = __unique_string()
    args["max_iter_name"] = __unique_string()
    args["tolerance_name"] = __unique_string()
    args["xmean_name"] = __unique_string()
    args["ymean_name"] = __unique_string()
   
    return args

## ========================================================================

def __igd_cleanup_temp_tbls(**args):
    """
    Drop all temporary tables used by IGD optimizer,
    including tables used in the possible normalization
    and IGD iterations.
    """
    plpy.execute("""
                 drop table if exists {tbl_ind_scales};
                 drop table if exists {tbl_dep_scale};
                 drop table if exists {tbl_data_scaled};
                 drop table if exists {tbl_igd_args};
                 drop table if exists pg_temp.{tbl_igd_state};
                 """.format(**args))
    return None

## ========================================================================

def __elastic_net_gaussian_igd_train(schema_madlib, tbl_source, col_ind_var,
                                     col_dep_var, tbl_result, lambda_value, alpha,
                                     normalization, optimizer_params, max_iter,
                                     tolerance, **kwargs):
    __elastic_net_validate_args(tbl_source, col_ind_var, col_dep_var, tbl_result, 
                                lambda_value, alpha, normalization, max_iter, tolerance)
    
    return __elastic_net_gaussian_igd_train_compute(schema_madlib, tbl_source, col_ind_var,
                                                    col_dep_var, tbl_result, lambda_value, alpha,
                                                    normalization, optimizer_params, max_iter,
                                                    tolerance, **kwargs)
    
## ========================================================================
    
def __elastic_net_gaussian_igd_train_compute(schema_madlib, tbl_source, col_ind_var,
                                             col_dep_var, tbl_result, lambda_value, alpha,
                                             normalization, optimizer_params, max_iter,
                                             tolerance, **kwargs):
    """
    Fit linear model with elastic net regularization using IGD optimization.

    @param tbl_source        Name of data source table
    @param col_ind_var       Name of independent variable column,
                             independent variable is an array
    @param col_dep_var       Name of dependent variable column
    @param tbl_result        Name of the table to store the results,
                             will return fitting coefficients and
                             likelihood
    @param lambda_value      The regularization parameter
    @param alpha             The elastic net parameter, [0, 1]
    @param normalization     Whether to normalize the variables
    @param optimizer_params  Parameters of the above optimizer, the format
                             is '{arg = value, ...}'::varchar[]
    """
    old_msg_level = plpy.execute("""
                                 select setting from pg_settings
                                 where name='client_min_messages'
                                 """)[0]['setting']
    plpy.execute("set client_min_messages to error")

    (dimension, row_num) = __tbl_dimension_rownum(tbl_source, col_ind_var)

    # generate a full dict to ease the following string format
    # including several temporary table names
    args = __igd_construct_dict(schema_madlib, tbl_source, col_ind_var, col_dep_var, tbl_result,
                                dimension, row_num, lambda_value, alpha, normalization,
                                max_iter, tolerance,
                                __igd_params_parser(optimizer_params))

    # use normalized data or not
    if normalization:
        __normalize_data(**args)
        args["tbl_used"] = args["tbl_data_scaled"]
        use_temp = "temp"
        args["col_ind_var_new"] = args["col_ind_var_norm_new"]
    else:
        args["tbl_used"] = tbl_source
        tbl_inter_result = tbl_result
        use_temp = ""
        args["col_ind_var_new"] = col_ind_var

    # create the temp table that passes parameter values to IGD optimizer
    __igd_create_tbl_args(**args)

    # perform the actual calculation
    iteration_run = __compute_gaussian_igd(schema_madlib, args["tbl_igd_args"],
                                           args["tbl_igd_state"], args["tbl_used"],
                                           args["col_ind_var_new"], col_dep_var, True,
                                           col_ind_var_new = args["col_ind_var_new"],
                                           dimension_name = args["dimension_name"],
                                           stepsize_name = args["stepsize_name"],
                                           lambda_name = args["lambda_name"],
                                           alpha_name = args["alpha_name"],
                                           total_rows_name = args["total_rows_name"],
                                           max_iter_name = args["max_iter_name"],
                                           tolerance_name = args["tolerance_name"],
                                           xmean_name = args["xmean_name"],
                                           ymean_name = args["ymean_name"])
        
    plpy.execute("""
                 drop table if exists {tbl_inter_result};
                 create {use_temp} table {tbl_inter_result} (
                    coefficients      double precision[],
                    intercept         double precision,
                    log_likelihood    double precision,
                    normalization     boolean,
                    iteration_run     integer)
                 """.format(use_temp = use_temp, **args))

    standardize_flag = "True" if normalization else "False"

    plpy.execute("""
                 insert into {tbl_inter_result}
                    select
                        (result).coefficients,
                        (result).intercept,
                        0.,
                        {standardize_flag},
                        {iteration_run}
                    from (
                        select {schema_madlib}.__gaussian_igd_result(_state) as result
                        from {tbl_igd_state}
                        where _iteration = {iteration_run}
                    ) t
                 """.format(iteration_run = iteration_run,
                            standardize_flag = standardize_flag,
                            **args))

    # compute the likelihood
    log_likelihood = __compute_log_likelihood(**args)
    plpy.execute("update {tbl_inter_result} set log_likelihood = {log_likelihood}".format(
        log_likelihood = log_likelihood, **args))
    
    if normalization:
        __utils_restore_linear_coef_scales(tbl_coef = args["tbl_inter_result"],
                                           col_coef = "coefficients",
                                           col_others = ["log_likelihood", "normalization", "iteration_run"],
                                           tbl_origin_coef = tbl_result,
                                           **args)
 
    # cleanup    
    __igd_cleanup_temp_tbls(**args)
    if normalization:
        plpy.execute("drop table if exists {tbl_inter_result}".format(**args))
    plpy.execute("set client_min_messages to " + old_msg_level)
    return None

## ========================================================================

def __compute_gaussian_igd(schema_madlib, tbl_args, tbl_state, tbl_source,
                           col_ind_var, col_dep_var, drop_table, **kwargs):
    """
    Driver function for elastic net with Gaussian response using IGD

    @param schema_madlib Name of the MADlib schema, properly escaped/quoted
    @param tbl_args Name of the (temporary) table containing all non-template
        arguments
    @param tbl_state Name of the (temporary) table containing the inter-iteration
        states
    @param rel_source Name of the relation containing input points
    @param col_ind_var Name of the independent variables column
    @param col_dep_var Name of the dependent variable column
    @param drop_table Boolean, whether to use IterationController (True) or
                      IterationControllerNoTableDrop (False)
    @param kwargs We allow the caller to specify additional arguments (all of
        which will be ignored though). The purpose of this is to allow the
        caller to unpack a dictionary whose element set is a superset of
        the required arguments by this function.
    
    @return The iteration number (i.e., the key) with which to look up the
        result in \c tbl_state
    """
    if drop_table:
        iterationCtrl = IterationController(
            rel_args = tbl_args,
            rel_state = tbl_state,
            stateType = "double precision[]",
            truncAfterIteration = False,
            schema_madlib = schema_madlib, # Identifiers start here
            rel_source = tbl_source,
            col_ind_var = col_ind_var,
            col_dep_var = col_dep_var,
            **kwargs)
    else:
        iterationCtrl = IterationControllerNoTableDrop(
            rel_args = tbl_args,
            rel_state = tbl_state,
            stateType = "double precision[]",
            truncAfterIteration = False,
            schema_madlib = schema_madlib, # Identifiers start here
            rel_source = tbl_source,
            col_ind_var = col_ind_var,
            col_dep_var = col_dep_var,
            **kwargs)

    with iterationCtrl as it:
        it.iteration = 0
        while True:
            # manually add the intercept term
            it.update("""
                      select
                        {schema_madlib}.__gaussian_igd_step(
                            {col_ind_var}::double precision[],
                            {col_dep_var}::double precision,
                            (select _state from {rel_state}
                                where _iteration = {iteration}),
                            (_args.{lambda_name})::double precision,
                            (_args.{alpha_name})::double precision,
                            (_args.{dimension_name})::integer,
                            (_args.{stepsize_name})::double precision,
                            (_args.{total_rows_name})::integer,
                            (_args.{xmean_name})::double precision[],
                            (_args.{ymean_name})::double precision
                      )
                      from {rel_source} as _src, {rel_args} as _args
                      """)

            if it.test("""
                       {iteration} > _args.{max_iter_name} or
                       {schema_madlib}.__gaussian_igd_state_diff(
                            (select _state from {rel_state}
                                where _iteration = {iteration} - 1),
                            (select _state from {rel_state}
                                where _iteration = {iteration})) < _args.{tolerance_name}
                       """):
                break

    return iterationCtrl.iteration
    