
import plpy
from elastic_net_utils import __process_results
from elastic_net_utils import __compute_log_likelihood
from utilities.utilities import __mad_version
from utilities.utilities import _array_to_string

def __elastic_net_generate_result (optimizer, iteration_run, **args):
    """
    Generate result table for all optimizers
    """
    plpy.execute("""
                 drop table if exists {tbl_inter_result};
                 create table {tbl_inter_result} (
                     family            text,
                     features          text[],
                     features_selected text[],
                     dense_coef        double precision[],
                     sparse_coef       double precision[],
                     intercept         double precision,
                     log_likelihood    double precision,
                     normalization     boolean,
                     iteration_run     integer)
                 """.format(**args))

    standardize_flag = "True" if args["normalization"] else "False"

    if optimizer == "fista":
        result_func = "__gaussian_fista_result(_state)"
        tbl_state = "{tbl_fista_state}"
    elif optimizer == "igd":
        result_func = "__gaussian_igd_result(_state, '{sq_str}'::double precision[], {threshold}::double precision)"
        tbl_state = "{tbl_igd_state}"
    
    result = plpy.execute(
        """
        select
            (result).coefficients as coef,
            (result).intercept as intercept
        from (
            select {{schema_madlib}}.{result_func} as result
            from {tbl_state}
            where _iteration = {{iteration_run}}
        ) t
        """.format(result_func = result_func, tbl_state = tbl_state).format(
            iteration_run = iteration_run,
            **args))[0]

    if args["normalization"]:
        (ind_std, ind_avg, dep_std, dep_avg) = __obtain_scales(**args)
    
        (coef, intercept) = __restore_scale(result["coef"], ind_std,
                                            ind_avg, dep_std, dep_avg)
    else:
        coef = result["coef"]
        intercept = result["intercept"]

    (features, features_selected, dense_coef, sparse_coef) = __process_results(coef, intercept,
                                                                               args["outstr_array"])

    # compute the likelihood
    if args["normalization"]:
        coef_str = _array_to_string(result["coef"]) # use un-restored coef
    else:
        coef_str = sparse_coef
    log_likelihood = __compute_log_likelihood(result["coef"], coef_str,
                                              result["intercept"], **args)
    plpy.execute("update {tbl_inter_result} set log_likelihood = {log_likelihood}".format(
        log_likelihood = log_likelihood, **args))

    plpy.execute(
        """
        insert into {tbl_inter_result} values
            ('gaussian', '{features}'::text[], '{features_selected}'::text[],
            '{dense_coef}'::double precision[], '{sparse_coef}'::double precision[],
            {intercept}, {log_likelihood}, {standardize_flag}, {iteration})
        """.format(
            features = features, features_selected = features_selected,
            dense_coef = dense_coef, sparse_coef = sparse_coef,
            intercept = intercept, log_likelihood = log_likelihood,
            standardize_flag = standardize_flag, iteration = iteration_run,
            **args))

    return None

# ========================================================================

def __obtain_scales (**args):
    """
    extract scales of ind and dep
    """
    version_wrapper = __mad_version()
    array_agg = version_wrapper.select_array_agg(args["schema_madlib"])

    result_ind = plpy.execute(
        """
        select
            {array_agg}(mean order by attr) as ind_avg,
            {array_agg}(std order by attr) as ind_std
        from {tbl_ind_scales}
        """.format(array_agg = array_agg, **args))[0]
    result_dep = plpy.execute(
        """
        select
            dep_avg, dep_std
        from {tbl_dep_scale}
        """.format(**args))[0]
    return (result_ind["ind_std"], result_ind["ind_avg"],
            result_dep["dep_std"], result_dep["dep_avg"])    

# ========================================================================

def __restore_scale (coef, ind_std, ind_avg, dep_std, dep_avg):
    """
    Restore the original scales
    """
    rcoef = coef
    rintercept = dep_avg
    for i in range(len(coef)):
        if ind_std[i] == 0:
            rcoef[i] = 0
        else:
            rcoef[i] = coef[i] * dep_std / ind_std[i]
            rintercept -= coef[i] * dep_std * ind_avg[i] / ind_std[i]
    return (rcoef, rintercept)