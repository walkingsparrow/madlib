/* ----------------------------------------------------------------------- *//** 
 *
 * @file ridge.sql_in
 *
 * @brief SQL functions for ridge regression
 * @date July 2012
 *
 * @sa For a brief introduction to ridge regression, see the module
 *     description \ref grp_ridge.
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4') -- ' 

/**
@addtogroup grp_ridge


@about

This module implements ridge regression (linear regression with Tikhonov regularization [1]).
Mathematically, this model seeks to find a weight vector \f$w\f$ (also referred as hyperplane) that, for any given training example set, minimizes:
\f[\min_{w \in R^N} \left[ \sum_{m=1}^M (w^{t} x_m - y_m)^2 \right] + \lambda \|w\|_2^2,\f]
where \f$x_m \in R^N\f$ are values of independent variables, and \f$y_m \in R\f$ are values of the dependent variable, \f$m = 1,...,M\f$.


@input

The <b>training examples</b> is expected to be of the following form:
<pre>{TABLE|VIEW} <em>input_table</em> (
    <em>independentVariables</em>    DOUBLE PRECISION[],
    <em>dependentVariables</em>    DOUBLE PRECISION
)</pre>

Null values are not expected.


@usage

- Get the vector of coefficients \f$ \boldsymbol w \f$:

<pre>SELECT madlib.ridge_newton_run(
    '<em>modelTableName</em>', '<em>sourceTableName</em>', '<em>independentVariables</em>', '<em>dependentVariables</em>' 
    [, <em>independentVariableDimension</em> [, <em>lambda</em> ]]); 
</pre>

  Output:
  <pre>      id | coefficients 
  -------+---------------
        ...
  </pre>
  The default value of \f$ \lambda \f$ is 0.1. The model table can contain multiple fits to different data sets, and each fit has a unique id number.
- Get the prediction on a data set using the fitted model:
<pre>
SELECT madlib.ridge_newton_predict('<em>coefficients</em>', '<em>independentVariables</em>')
FROM sourceTableName, modelTableName WHERE modelTableName.id=fitId;
</pre>

Please find descriptions of SQL functions in ridge.sql_in

we offer Newton's method solver (optimizer) for ridge regression. For ridge regression, this is a one-pass algorithm.

Since Hessian is stored in memory, we expect the number of coefficients is less than 32767 (2^15 - 1).

@examp

-# Prepare an input table/view:
\code
CREATE TABLE ridge_data (
    ind_var DOUBLE PRECISION[],
    dep_var DOUBLE PRECISION
);
\endcode     
-# Populate the input table with some data, which should be well-conditioned, e.g.:
\code
mydb=# INSERT INTO ridge_data values ({1, 1}, 0.89);
mydb=# INSERT INTO ridge_data values ({0.67, -0.06}, 0.3);
...
mydb=# INSERT INTO ridge_data values ({0.15, -1.3}, -1.3);
\endcode   
-# call ridge_newton_run() to learn coefficients, e.g.:  
\code
mydb=# SELECT madlib.ridge_newton_run('ridge_model', 'ridge_data', 'ind_var', 'dep_var', 2, 0.1);
\endcode
-# call ridge_newton_predict() to predict results. you usually need the model id output from the learning query to locate the model, assuming 1, e.g.:  
\code
mydb=# select madlib.ridge_newton_predict(coefficients, ind_var)
mydb-# from ridge_data, ridge_model
mydb-# where ridge_model.id = 1;
\endcode


@literature

[1] Tikhonov regularization. http://en.wikipedia.org/wiki/Tikhonov_regularization

[2] Regularization: Ridge Regression and the LASSO. http://www-stat.stanford.edu/~owen/courses/305/Rudyregularization.pdf

*/


--------------------------------------------------------------------------
-- create SQL functions for Newton's method optimizer
--------------------------------------------------------------------------
CREATE FUNCTION MADLIB_SCHEMA.__ridge_newton_transition(
    state           DOUBLE PRECISION[],
    ind_var         DOUBLE PRECISION[],
    dep_var         DOUBLE PRECISION,
    previous_state  DOUBLE PRECISION[],
    dimension       SMALLINT,
    lambda          DOUBLE PRECISION)
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME', 'ridge_newton_transition'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.__ridge_newton_merge(
    state1 DOUBLE PRECISION[],
    state2 DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME', 'ridge_newton_merge'
LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION MADLIB_SCHEMA.__ridge_newton_final(
    state DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME', 'ridge_newton_final'
LANGUAGE C IMMUTABLE STRICT;

/**
 * @internal
 * @brief Perform one iteration of the incremental gradient
 *        method for computing ridge regression
 */
CREATE AGGREGATE MADLIB_SCHEMA.__ridge_newton_step(
    /*+ ind_var */          DOUBLE PRECISION[],
    /*+ dep_var */          DOUBLE PRECISION,
    /*+ previous_state */   DOUBLE PRECISION[], 
    /*+ dimension */        SMALLINT,
    /*+ lambda */           DOUBLE PRECISION) (
    STYPE = DOUBLE PRECISION[],
    SFUNC = MADLIB_SCHEMA.__ridge_newton_transition,
    m4_ifdef(`GREENPLUM',`prefunc = MADLIB_SCHEMA.__ridge_newton_merge,')
    FINALFUNC = MADLIB_SCHEMA.__ridge_newton_final,
    INITCOND = '{0,0,0,0,0,0}'
);

CREATE FUNCTION MADLIB_SCHEMA.__ridge_newton_result(
    /*+ state */ DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[] AS
'MODULE_PATHNAME', 'internal_ridge_newton_result'
LANGUAGE c IMMUTABLE STRICT;

/**
 * @brief Ridge regression using Newton's method
 *
 * This function takes as input the table representation of a set of examples
 * in (FLOAT8[], FLOAT8) format and outputs the coefficients that minimizes
 * the ordinary least squares with a L2 regularization term.
 *
 *   @param rel_output  Name of the table that the factors will be appended to
 *   @param rel_source  Name of the table/view with the source data
 *   @param col_ind_var  Name of the column containing feature vector (independent variables)
 *   @param col_dep_var  Name of the column containing label (dependent variable)
 *   @param dimension  Number of features (independent variables)
 *   @param lambda  Hyper-parameter that decides how much the L1 regularization takes effect
 * 
 */
CREATE FUNCTION MADLIB_SCHEMA.ridge_newton_train(
    tbl_source      VARCHAR,
    col_ind_var     VARCHAR,
    col_dep_var     VARCHAR,
    tbl_output      VARCHAR,
    lambda          DOUBLE PRECISION, /*+ DEFAULT 0.1 */
    normalization   BOOLEAN, -- default f to save computation amount
    dimension       INTEGER /*+ DEFAULT 'SELECT max(array_upper(col_ind_var, 1)) FROM rel_source' */
) RETURNS VOID AS $$
DECLARE
    tbl_inter           VARCHAR;
    text_src            VARCHAR;
    coef                DOUBLE PRECISION[];
    old_messages        VARCHAR;
    tbl_ind_scales      VARCHAR := MADLIB_SCHEMA.__cv_unique_string();
    tbl_dep_scale       VARCHAR := MADLIB_SCHEMA.__cv_unique_string();
    tbl_data_scaled     VARCHAR := MADLIB_SCHEMA.__cv_unique_string();
    tbl_inter_result    VARCHAR := MADLIB_SCHEMA.__cv_unique_string();
BEGIN
    old_messages := (SELECT setting FROM pg_settings WHERE name = 'client_min_messages');
    EXECUTE 'SET client_min_messages TO warning';

    -- EXECUTE 'SELECT max(array_upper('|| col_ind_var ||', 1)) FROM '|| tbl_source INTO dimension;
    
    IF normalization THEN
        PERFORM MADLIB_SCHEMA.__ridge_ind_var_scales(tbl_source, col_ind_var, dimension, tbl_ind_scales);
        PERFORM MADLIB_SCHEMA.__ridge_dep_var_scale(tbl_source, col_dep_var, tbl_dep_scale);
        PERFORM MADLIB_SCHEMA.__ridge_normalize_data(tbl_source, col_ind_var, dimension, col_dep_var,
                                                    tbl_ind_scales, tbl_dep_scale, tbl_data_scaled);
        tbl_inter := tbl_data_scaled;
    ELSE
        tbl_inter := tbl_source;
    END IF;
    
    -- create result table if it does not exist
    IF normalization IS False THEN
        tbl_inter_result := tbl_output;
    END IF;
    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_inter_result ||';
        CREATE TABLE ' || tbl_inter_result || ' (
            coefficients    DOUBLE PRECISION[],
            normalization   BOOLEAN)';

    -- -- A work-around for GPDB not supporting RETURNING for INSERT
    -- -- We generate an id using nextval before INSERT
    -- EXECUTE '
    --     SELECT nextval(' || quote_literal(rel_output || '_id_seq') ||'::regclass)'
    --     INTO model_id;

    -- Perform acutal computation and output model
    EXECUTE '
        INSERT INTO ' || tbl_inter_result || '
        SELECT result, False
        FROM (
            SELECT MADLIB_SCHEMA.__ridge_newton_result(
                MADLIB_SCHEMA.__ridge_newton_step(
                    ('|| tbl_inter ||'.'|| col_ind_var ||')::FLOAT8[],
                    ('|| tbl_inter ||'.'|| col_dep_var ||')::FLOAT8, 
                    (NULL)::FLOAT8[],
                    ('|| dimension ||')::INT2,
                    ('|| lambda ||')::FLOAT8
                    )
                ) AS result
            FROM '|| tbl_inter ||' 
            ) subq';

    IF normalization THEN
        PERFORM MADLIB_SCHEMA.__ridge_restore_linear_coef_scales(tbl_inter_result, 'coefficients', '{normalization}'::VARCHAR[],
                                                                dimension, tbl_ind_scales, tbl_dep_scale, tbl_output);
        EXECUTE 'UPDATE '|| tbl_output ||' SET normalization =True';
    END IF;

    
    EXECUTE 'DROP TABLE IF EXISTS '|| tbl_ind_scales ||';
            DROP TABLE IF EXISTS '|| tbl_dep_scale ||';
            DROP TABLE IF EXISTS '|| tbl_data_scaled;

    IF normalization THEN
        EXECUTE 'DROP TABLE IF EXISTS '|| tbl_inter_result;
    END IF;
            
    EXECUTE 'SET client_min_messages TO ' || old_messages;
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION MADLIB_SCHEMA.ridge_newton_train(
    rel_source      VARCHAR,
    col_ind_var     VARCHAR,
    col_dep_var     VARCHAR,
    rel_output      VARCHAR,
    lambda          DOUBLE PRECISION, /*+ DEFAULT 0.1 */
    normalization   BOOLEAN -- default f to save computation amount
) RETURNS VOID AS $$
DECLARE
    dimension INTEGER;
BEGIN
    EXECUTE '
        SELECT max(array_upper(' || col_ind_var || ', 1))
        FROM ' || rel_source
        INTO dimension;

    PERFORM MADLIB_SCHEMA.ridge_newton_train($1, $2, $3, $4, $5, $6, dimension);
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION MADLIB_SCHEMA.ridge_newton_train(
    rel_source      VARCHAR,
    col_ind_var     VARCHAR,
    col_dep_var     VARCHAR,
    rel_output      VARCHAR,
    lambda          DOUBLE PRECISION /*+ DEFAULT 0.1 */
) RETURNS VOID AS $$
BEGIN
    PERFORM MADLIB_SCHEMA.ridge_newton_train($1, $2, $3, $4, $5, f);
END;
$$ LANGUAGE plpgsql VOLATILE;

/**
 * @brief Prediction (real value) using learned coefficients for a given example.
 *
 * @param coefficients  Weight vector (hyperplane, classifier)
 * @param ind_var  Features (independent variables)
 *
 */
CREATE FUNCTION MADLIB_SCHEMA.__ridge_linear_newton_predict(
    coefficients    DOUBLE PRECISION[],
    ind_var         DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION
AS 'MODULE_PATHNAME', 'ridge_newton_predict'
LANGUAGE C IMMUTABLE STRICT;

-- predict multiple data points given in a table
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.ridge_linear_newton_predict(
    tbl_model       VARCHAR,
    tbl_new_data    VARCHAR,
    ind_var         VARCHAR,
    id_var          VARCHAR,    -- ID column
    tbl_prediction  VARCHAR
) RETURNS VOID AS $$
DECLARE
    old_messages    VARCHAR;
    normalization   BOOLEAN;
BEGIN
    old_messages := (SELECT setting FROM pg_settings WHERE name = 'client_min_messages');
    EXECUTE 'SET client_min_messages TO warning';
    
    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_prediction ||';
        CREATE TABLE '|| tbl_prediction ||' AS
            SELECT
                '|| tbl_new_data ||'.'|| id_var ||' AS id,
                MADLIB_SCHEMA.__ridge_linear_newton_predict(
                    coefficients,
                    '|| tbl_new_data ||'.'|| ind_var ||') AS prediction
            FROM
                '|| tbl_new_data ||',
                '|| tbl_model;

    EXECUTE 'SELECT normalization FROM '|| tbl_model INTO normalization;
    IF normalization THEN
        EXECUTE 'UPDATE '|| tbl_prediction ||' SET prediction = prediction + intercept FROM '|| tbl_model;
    END IF;

    EXECUTE 'SET client_min_messages TO ' || old_messages;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- compare the prediction and actual values
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.mse_error(
    tbl_prediction  VARCHAR,    -- predicted values
    tbl_actual      VARCHAR,
    id_actual       VARCHAR,
    values_actual   VARCHAR,
    tbl_error       VARCHAR
) RETURNS VOID AS $$
DECLARE
    error           DOUBLE PRECISION;
    old_messages    VARCHAR; 
BEGIN
    old_messages := (SELECT setting FROM pg_settings WHERE name = 'client_min_messages');
    EXECUTE 'SET client_min_messages TO warning';

    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_error ||';
        CREATE TABLE '|| tbl_error ||' AS
        SELECT
            avg(('|| tbl_prediction ||'.prediction - '|| tbl_actual ||'.'|| values_actual ||')^2) as mean_squared_error
        FROM
            '|| tbl_prediction ||',
            '|| tbl_actual ||'
        WHERE
            '|| tbl_prediction ||'.id = '|| tbl_actual ||'.'|| id_actual;

    EXECUTE 'SET client_min_messages TO ' || old_messages;
END;
$$ LANGUAGE plpgsql VOLATILE;

----------------------------------------------------------------
----------------------------------------------------------------
-- compute the independent variables scales
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ridge_ind_var_scales(
    tbl_data        VARCHAR,
    col_ind_var     VARCHAR,
    dimension       INTEGER,
    tbl_scales      VARCHAR
) RETURNS VOID AS $$
DECLARE
    foo         VARCHAR := MADLIB_SCHEMA.__cv_unique_string(); -- intermdediate table name
BEGIN
    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_scales ||';
        CREATE TEMP TABLE '|| tbl_scales ||' AS
            SELECT
                attr,
                avg(val) AS mean,
                stddev(val) AS std
            FROM (
                SELECT
                    generate_series(1, '|| dimension::VARCHAR ||') as attr,
                    unnest('|| col_ind_var ||') AS val
                FROM
                    '|| tbl_data ||'
                ) AS '|| foo ||'
            GROUP BY attr';
END;
$$ LANGUAGE plpgsql VOLATILE;

-- compute the dependent variable scale
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ridge_dep_var_scale(
    tbl_data        VARCHAR,
    col_dep_var     VARCHAR,
    tbl_scale       VARCHAR     -- scale including mean and std
) RETURNS VOID AS $$
BEGIN
    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_scale ||';
        CREATE TEMP TABLE '|| tbl_scale ||' AS
            SELECT
                avg('|| col_dep_var ||') AS dep_avg,
                stddev('|| col_dep_var ||') AS dep_std
            FROM
                '|| tbl_data;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- normalize both the independent data and dependent data
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ridge_normalize_data(
    tbl_data        VARCHAR,    -- original data
    col_ind_var     VARCHAR,    -- independent variables column 
    dimension       INTEGER,    -- length of independent variable array
    col_dep_var     VARCHAR,    -- dependent variable column
    tbl_ind_scales  VARCHAR,    -- independent variables scales array
    tbl_dep_scale   VARCHAR,    -- dependent variable scale 
    tbl_data_scaled VARCHAR     -- scaled data result
) RETURNS VOID AS $$
DECLARE
    foos        VARCHAR := MADLIB_SCHEMA.__cv_unique_string(); -- intermediate table name
    goos        VARCHAR := MADLIB_SCHEMA.__cv_unique_string(); -- intermediate table name
BEGIN
    EXECUTE 'DROP TABLE IF EXISTS '|| tbl_data_scaled;
    EXECUTE '
        CREATE TEMP TABLE '|| tbl_data_scaled ||' AS
            SELECT
                array_agg(val ORDER BY attr ) AS '|| col_ind_var ||',
                max(dep_var) AS '|| col_dep_var ||'
            FROM (
                SELECT
                    ids,
                    '|| foos ||'.attr AS attr,
                    (dep_var - dep_avg) / dep_std AS dep_var,
                    (
                        CASE WHEN std = 0 THEN
                            val - mean
                        ELSE
                            (val - mean) / std
                        END
                    ) AS val
                FROM
                    '|| tbl_ind_scales ||',
                    '|| tbl_dep_scale ||',
                    (
                        SELECT
                            row_number() OVER () AS ids,
                            '|| col_dep_var ||' AS dep_var,
                            generate_series(1, '|| dimension::VARCHAR ||') AS attr,
                            unnest('|| col_ind_var ||') AS val
                        FROM
                            '|| tbl_data ||'
                    ) AS '|| foos ||'
                WHERE '|| tbl_ind_scales ||'.attr = '|| foos ||'.attr
            ) AS '|| goos ||'
            GROUP BY ids
    ';
END;
$$ LANGUAGE plpgsql VOLATILE;

-- put normalized fitting result together with scales
-- to be used for nonlinear fitting
-- non-linear fitting just uses normalized fitting coefficients to get prediction
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ridge_gather_results(
    tbl_coef        VARCHAR,    -- table contains the result of fitting
    col_coef        VARCHAR,    -- column for coefficients
    col_others      VARCHAR,
    tbl_ind_scales  VARCHAR,
    tbl_dep_scale   VARCHAR,
    tbl_all_results VARCHAR     -- the resulting coefficients have been restored to the original scales
) RETURNS VOID AS $$
DECLARE
    col_others_string VARCHAR := MADLIB_SCHEMA.__cv_produce_col_name_string(tbl_coef, col_others);
BEGIN
    EXECUTE 'DROP TABLE IF EXISTS '|| tbl_all_results;
    EXECUTE '
        CREATE TABLE '|| tbl_all_results ||' AS
            SELECT
                coefficients AS '|| col_coef ||',
                intercept AS intercept,
                array_agg('|| tbl_ind_scales ||'.mean ORDER BY '|| tbl_ind_scales ||'.attr) AS ind_var_mean,
                '|| tbl_ind_scales ||'.std AS ind_var_std,
                '|| tbl_dep_scale ||'.dep_avg AS dep_var_mean,
                '|| tbl_dep_scale ||'.dep_std AS dep_var_std,
                '|| col_others_string ||'
            FROM
                '|| tbl_coef ||',
                '|| tbl_ind_scales ||',
                '|| tbl_dep_scale;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- restore the scales of coefficients for linear model
-- for non-linear models, the coefficients may not be able to restore like this
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ridge_restore_linear_coef_scales(
    tbl_coef        VARCHAR,    -- table contains the result of fitting
    col_coef        VARCHAR,    -- column for coefficients
    col_others      VARCHAR[],
    dimension       INTEGER,
    tbl_ind_scales  VARCHAR,
    tbl_dep_scale   VARCHAR,
    tbl_origin_coef VARCHAR     -- the resulting coefficients have been restored to the original scales
) RETURNS VOID AS $$
DECLARE
    subq2   VARCHAR := MADLIB_SCHEMA.__cv_unique_string(); -- intermediate table name
    col_others_string VARCHAR := MADLIB_SCHEMA.__cv_produce_col_name_string(tbl_coef, col_others);
BEGIN
    EXECUTE 'DROP TABLE IF EXISTS '|| tbl_origin_coef;
    EXECUTE '
        CREATE TABLE '|| tbl_origin_coef ||' AS
            SELECT
                subq1.coefficients AS '|| col_coef ||',
                subq1.intercept + subq1.dep_avg AS intercept,
                t.ind_var_mean,
                t.ind_var_std,
                '|| tbl_dep_scale ||'.dep_avg AS dep_var_mean,
                '|| tbl_dep_scale ||'.dep_std AS dep_var_std,
                '|| col_others_string ||'
            FROM (
                SELECT
                    array_agg(val ORDER BY attr) AS coefficients,
                    sum(intercept_tmp) AS intercept,
                    max(dep_avg) AS dep_avg
                FROM (
                    SELECT
                        '|| subq2 ||'.attr,
                        (
                            CASE WHEN std = 0 THEN
                                0.
                            ELSE
                                coef * dep_std / std
                            END
                        ) AS val,
                        (
                            CASE WHEN std = 0 THEN
                                0.
                            ELSE
                                - coef * dep_std * mean / std
                            END
                        ) AS intercept_tmp,
                        dep_avg
                    FROM
                        '|| tbl_ind_scales ||',
                        '|| tbl_dep_scale ||',
                        (
                            SELECT
                                generate_series(1, '|| dimension::VARCHAR ||') AS attr,
                                unnest('|| col_coef ||') AS coef
                            FROM '|| tbl_coef ||'
                        ) AS '|| subq2 ||'
                    WHERE '|| tbl_ind_scales ||'.attr = '|| subq2 ||'.attr
                ) AS subq3
            ) AS subq1,
            '|| tbl_coef ||',
            (
                SELECT
                    array_agg('|| tbl_ind_scales ||'.mean ORDER BY '|| tbl_ind_scales ||'.attr) AS ind_var_mean,
                    array_agg('|| tbl_ind_scales ||'.std ORDER BY '|| tbl_ind_scales ||'.attr) AS ind_var_std
                FROM '|| tbl_ind_scales ||'
            ) t,
            '|| tbl_dep_scale;
END;
$$ LANGUAGE plpgsql VOLATILE;

------------------------------------------------------------------------
/*
    cross validation for ridge only
*/
/**
 * @brief Run cross validation for ridge regression
 *
 * This function does not have the limitation on the number of lambda values
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.ridge_newton_cv(
    data_tbl            VARCHAR,
    data_id             VARCHAR,
    id_is_random        BOOLEAN,
    col_ind             VARCHAR,
    col_dep             VARCHAR,
    lambda_values       DOUBLE PRECISION[],
    normalization       BOOLEAN,
    fold_num            INTEGER,
    upto_fold           INTEGER,
    validation_result   VARCHAR
) RETURNS VOID AS $$
DECLARE
    oldClientMinMessages    VARCHAR;
    tbl_used                VARCHAR; -- table name that will be used
    tbl_all_data            VARCHAR := MADLIB_SCHEMA.__cv_unique_string();  -- if need to copy the data, this is the copied table name
    tbl_inter               VARCHAR := MADLIB_SCHEMA.__cv_unique_string();  -- table name before normalization
    tbl_train               VARCHAR := MADLIB_SCHEMA.__cv_unique_string();  -- table name for training
    tbl_valid               VARCHAR := MADLIB_SCHEMA.__cv_unique_string();  -- table name for validation
    col_random_id           VARCHAR := MADLIB_SCHEMA.__cv_unique_string();  -- column name for random id
    tbl_random_id           VARCHAR := MADLIB_SCHEMA.__cv_unique_string();  -- table for random ID mapping
    tbl_coef                VARCHAR := MADLIB_SCHEMA.__cv_unique_string();
    tbl_accum_error         VARCHAR := MADLIB_SCHEMA.__cv_unique_string();  -- accumulate the error information
    row_num                 INTEGER;
    data_cols               VARCHAR[];
    error                   DOUBLE PRECISION;
    lambda                  DOUBLE PRECISION;
    dimension               INTEGER;
    accum_count             INTEGER;
    coef_count              INTEGER;
    tbl_ind_scales          VARCHAR := MADLIB_SCHEMA.__cv_unique_string();
    tbl_dep_scale           VARCHAR := MADLIB_SCHEMA.__cv_unique_string();
BEGIN
    oldClientMinMessages :=  (SELECT setting FROM pg_settings WHERE name = 'client_min_messages');
    EXECUTE 'SET client_min_messages TO warning';

    data_cols := array[col_ind, col_dep];
    IF data_id IS NULL THEN -- unique ID column is not given, has to copy the data and create the ID
        PERFORM MADLIB_SCHEMA.__cv_copy_data_with_id(data_tbl, data_cols, tbl_all_data, col_random_id);
        tbl_used := tbl_all_data;
    ELSIF id_is_random THEN -- unique ID column is given and is random
        tbl_used := data_tbl; -- nothing needs to be done to the original data table
    ELSE -- the provided unique ID is not random, create a table mapping the given ID to a random ID
        PERFORM MADLIB_SCHEMA.__cv_generate_random_id(data_tbl, data_id, tbl_random_id, col_random_id, data_id);
        tbl_used := data_tbl;
    END IF;

    -- k-fold cross-validation
    EXECUTE 'SELECT count(*) FROM '|| data_tbl INTO row_num;
    EXECUTE 'SELECT max(array_upper('|| col_ind ||', 1)) FROM '|| data_tbl INTO dimension;
    
    IF fold_num <= 1 THEN
        RAISE EXCEPTION 'Cross validation total fold number should be larger than 1!';
    END IF;
    
    IF upto_fold < 1 OR upto_fold > fold_num THEN
        RAISE EXCEPTION 'Cannot run with cross validation fold smalled than 1 or larger than total fold number!';
    END IF;

    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_coef ||';
        CREATE TEMP TABLE '|| tbl_coef ||' (id integer, coef double precision[], intercept double precision)
    ';    
    
    accum_count := 0;
    coef_count := 0;
    FOR k IN 1..upto_fold LOOP
        -- split data into train and validation parts
        IF (data_id IS NULL) OR (data_id IS NOT NULL AND id_is_random) THEN
            PERFORM MADLIB_SCHEMA.__cv_split_data(tbl_used, col_random_id, row_num, tbl_inter, tbl_valid, fold_num, k);
        ELSE
            PERFORM MADLIB_SCHEMA.__cv_split_data(tbl_used, tbl_random_id, col_random_id, data_id,
                                                row_num, tbl_inter, tbl_valid, fold_num, k);
        END IF;

        IF normalization THEN
            PERFORM MADLIB_SCHEMA.__ridge_ind_var_scales(tbl_inter, col_ind, dimension, tbl_ind_scales);
            PERFORM MADLIB_SCHEMA.__ridge_dep_var_scale(tbl_inter, col_dep, tbl_dep_scale);
            PERFORM MADLIB_SCHEMA.__ridge_normalize_data(tbl_inter, col_ind, dimension, col_dep,
                                                        tbl_ind_scales, tbl_dep_scale, tbl_train);
        ELSE
            tbl_train := tbl_inter;
        END IF;

        FOREACH lambda IN ARRAY lambda_values LOOP
            coef_count := coef_count + 1;
            EXECUTE '
                INSERT INTO '|| tbl_coef ||'
                    SELECT '|| coef_count ||', result, 0
                    FROM (
                        SELECT MADLIB_SCHEMA.__ridge_newton_result(
                            MADLIB_SCHEMA.__ridge_newton_step(
                            ('|| tbl_train ||'.'|| col_ind ||')::FLOAT8[],
                            ('|| tbl_train ||'.'|| col_dep ||')::FLOAT8, 
                            (NULL)::FLOAT8[],
                            ('|| dimension ||')::INT2,
                            ('|| lambda ||')::FLOAT8
                            )
                        ) AS result
                        FROM ' || tbl_train || ' 
                    ) subq';
                    
            IF normalization THEN
                coef_count := coef_count + 1;
                EXECUTE '
                    INSERT INTO '|| tbl_coef ||'
                    SELECT
                        '|| coef_count ||',
                        coefficients,
                        intercept + dep_avg
                    FROM (
                        SELECT
                            array_agg(val ORDER BY attr) AS coefficients,
                            sum(intercept_tmp) AS intercept,
                            max(dep_avg) AS dep_avg
                        FROM (
                            SELECT
                                subq2.attr,
                                (
                                    CASE WHEN std = 0 THEN
                                        0.
                                    ELSE
                                        coef * dep_std / std
                                    END
                                ) AS val,
                                (
                                    CASE WHEN std = 0 THEN
                                        0.
                                    ELSE
                                        - coef * dep_std * mean / std
                                    END
                                ) AS intercept_tmp,
                                dep_avg
                            FROM
                                '|| tbl_ind_scales ||',
                                '|| tbl_dep_scale ||',
                                (
                                    SELECT
                                        generate_series(1, '|| dimension::VARCHAR ||') AS attr,
                                        unnest(coef) AS coef
                                    FROM '|| tbl_coef ||'
                                    WHERE id = '|| coef_count - 1 ||'
                                ) AS subq2
                            WHERE '|| tbl_ind_scales ||'.attr = subq2.attr
                        ) AS subq3
                    ) AS subq1                
                ';            
            END IF;
        
            EXECUTE '
                SELECT
                    avg((real_value - pred)^2)
                FROM (
                    SELECT
                        MADLIB_SCHEMA.__ridge_linear_newton_predict(coef, '|| tbl_valid ||'.'|| col_ind ||') + intercept AS pred,
                        '|| tbl_valid ||'.'|| col_dep ||' AS real_value
                    FROM '|| tbl_valid ||', '|| tbl_coef ||'
                    WHERE '|| tbl_coef ||'.id = '|| coef_count ||'
                    ) t
                ' INTO error;
            
            -- accumulate the measured error result
            accum_count := accum_count + 1;
            IF accum_count = 1 THEN
                EXECUTE '
                    CREATE TEMP TABLE '|| tbl_accum_error ||' (lambda DOUBLE PRECISION, mean_squared_error DOUBLE PRECISION)';
                EXECUTE '
                    INSERT INTO '|| tbl_accum_error ||' VALUES ('|| lambda ||', '|| error ||')';
            ELSE
                EXECUTE '
                    INSERT INTO '|| tbl_accum_error ||' VALUES ('|| lambda ||', '|| error ||')';
            END IF;
            
        END LOOP;
    END LOOP;

    PERFORM MADLIB_SCHEMA.__cv_summarize_result(tbl_accum_error, validation_result, 'lambda');

    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_all_data ||';
        DROP TABLE IF EXISTS '|| tbl_train ||';
        DROP TABLE IF EXISTS '|| tbl_inter ||';
        DROP TABLE IF EXISTS '|| tbl_valid ||';
        DROP TABLE IF EXISTS '|| tbl_random_id ||';
        DROP TABLE IF EXISTS '|| tbl_coef ||';
        DROP TABLE IF EXISTS '|| tbl_accum_error;

    EXECUTE 'SET client_min_messages TO ' || oldClientMinMessages;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- column standard deviation
