/* ----------------------------------------------------------------------- *//** 
 *
 * @file ridge.sql_in
 *
 * @brief SQL functions for ridge regression
 * @date July 2012
 *
 * @sa For a brief introduction to ridge regression, see the module
 *     description \ref grp_ridge.
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4') -- ' 

/**
@addtogroup grp_ridge


@about

This module implements ridge regression (linear regression with Tikhonov regularization [1]).
Mathematically, this model seeks to find a weight vector \f$w\f$ (also referred as hyperplane) that, for any given training example set, minimizes:
\f[\min_{w \in R^N} \left[ \sum_{m=1}^M (w^{t} x_m - y_m)^2 \right] + \lambda \|w\|_2^2,\f]
where \f$x_m \in R^N\f$ are values of independent variables, and \f$y_m \in R\f$ are values of the dependent variable, \f$m = 1,...,M\f$.


@input

The <b>training examples</b> is expected to be of the following form:
<pre>{TABLE|VIEW} <em>input_table</em> (
    <em>independentVariables</em>    DOUBLE PRECISION[],
    <em>dependentVariables</em>    DOUBLE PRECISION
)</pre>

Null values are not expected.


@usage

- Get the vector of coefficients \f$ \boldsymbol w \f$:

<pre>SELECT madlib.ridge_newton_run(
    '<em>modelTableName</em>', '<em>sourceTableName</em>', '<em>independentVariables</em>', '<em>dependentVariables</em>' 
    [, <em>independentVariableDimension</em> [, <em>lambda</em> ]]); 
</pre>

  Output:
  <pre>      id | coefficients 
  -------+---------------
        ...
  </pre>
  The default value of \f$ \lambda \f$ is 0.1. The model table can contain multiple fits to different data sets, and each fit has a unique id number.
- Get the prediction on a data set using the fitted model:
<pre>
SELECT madlib.ridge_newton_predict('<em>coefficients</em>', '<em>independentVariables</em>')
FROM sourceTableName, modelTableName WHERE modelTableName.id=fitId;
</pre>

Please find descriptions of SQL functions in ridge.sql_in

we offer Newton's method solver (optimizer) for ridge regression. For ridge regression, this is a one-pass algorithm.

Since Hessian is stored in memory, we expect the number of coefficients is less than 32767 (2^15 - 1).

@examp

-# Prepare an input table/view:
\code
CREATE TABLE ridge_data (
    ind_var DOUBLE PRECISION[],
    dep_var DOUBLE PRECISION
);
\endcode     
-# Populate the input table with some data, which should be well-conditioned, e.g.:
\code
mydb=# INSERT INTO ridge_data values ({1, 1}, 0.89);
mydb=# INSERT INTO ridge_data values ({0.67, -0.06}, 0.3);
...
mydb=# INSERT INTO ridge_data values ({0.15, -1.3}, -1.3);
\endcode   
-# call ridge_newton_run() to learn coefficients, e.g.:  
\code
mydb=# SELECT madlib.ridge_newton_run('ridge_model', 'ridge_data', 'ind_var', 'dep_var', 2, 0.1);
\endcode
-# call ridge_newton_predict() to predict results. you usually need the model id output from the learning query to locate the model, assuming 1, e.g.:  
\code
mydb=# select madlib.ridge_newton_predict(coefficients, ind_var)
mydb-# from ridge_data, ridge_model
mydb-# where ridge_model.id = 1;
\endcode


@literature

[1] Tikhonov regularization. http://en.wikipedia.org/wiki/Tikhonov_regularization

[2] Regularization: Ridge Regression and the LASSO. http://www-stat.stanford.edu/~owen/courses/305/Rudyregularization.pdf

*/


--------------------------------------------------------------------------
-- create SQL functions for Newton's method optimizer
--------------------------------------------------------------------------
CREATE FUNCTION MADLIB_SCHEMA.ridge_newton_transition(
    state           DOUBLE PRECISION[],
    ind_var         DOUBLE PRECISION[],
    dep_var         DOUBLE PRECISION,
    previous_state  DOUBLE PRECISION[],
    dimension       SMALLINT,
    lambda          DOUBLE PRECISION)
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.ridge_newton_merge(
    state1 DOUBLE PRECISION[],
    state2 DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION MADLIB_SCHEMA.ridge_newton_final(
    state DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

/**
 * @internal
 * @brief Perform one iteration of the incremental gradient
 *        method for computing ridge regression
 */
CREATE AGGREGATE MADLIB_SCHEMA.ridge_newton_step(
    /*+ ind_var */          DOUBLE PRECISION[],
    /*+ dep_var */          DOUBLE PRECISION,
    /*+ previous_state */   DOUBLE PRECISION[], 
    /*+ dimension */        SMALLINT,
    /*+ lambda */           DOUBLE PRECISION) (
    STYPE=DOUBLE PRECISION[],
    SFUNC=MADLIB_SCHEMA.ridge_newton_transition,
    m4_ifdef(`GREENPLUM',`prefunc=MADLIB_SCHEMA.ridge_newton_merge,')
    FINALFUNC=MADLIB_SCHEMA.ridge_newton_final,
    INITCOND='{0,0,0,0,0,0}'
);

CREATE FUNCTION MADLIB_SCHEMA.internal_ridge_newton_result(
    /*+ state */ DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[] AS
'MODULE_PATHNAME'
LANGUAGE c IMMUTABLE STRICT;

/**
 * @brief Ridge regression using Newton's method
 *
 * This function takes as input the table representation of a set of examples
 * in (FLOAT8[], FLOAT8) format and outputs the coefficients that minimizes
 * the ordinary least squares with a L2 regularization term.
 *
 *   @param rel_output  Name of the table that the factors will be appended to
 *   @param rel_source  Name of the table/view with the source data
 *   @param col_ind_var  Name of the column containing feature vector (independent variables)
 *   @param col_dep_var  Name of the column containing label (dependent variable)
 *   @param dimension  Number of features (independent variables)
 *   @param lambda  Hyper-parameter that decides how much the L1 regularization takes effect
 * 
 */
CREATE FUNCTION MADLIB_SCHEMA.ridge_newton_train(
    rel_source      VARCHAR,
    col_ind_var     VARCHAR,
    col_dep_var     VARCHAR,
    rel_output      VARCHAR, 
    dimension       INTEGER /*+ DEFAULT 'SELECT max(array_upper(col_ind_var, 1)) FROM rel_source' */,
    lambda          DOUBLE PRECISION /*+ DEFAULT 0.1 */)
RETURNS VOID AS $$
DECLARE
    old_messages    VARCHAR;
    text_src        VARCHAR;
    coef            DOUBLE PRECISION[];
BEGIN
    text_src = textin(regclassout(rel_source));
    /* RAISE NOTICE 'Source table % to be used: dimension %', text_src, dimension; */

    -- create result table if it does not exist
    EXECUTE '
        DROP TABLE IF EXISTS '|| rel_output ||';
        CREATE TABLE ' || rel_output || ' (
            coefficients    DOUBLE PRECISION[])';

    -- -- A work-around for GPDB not supporting RETURNING for INSERT
    -- -- We generate an id using nextval before INSERT
    -- EXECUTE '
    --     SELECT nextval(' || quote_literal(rel_output || '_id_seq') ||'::regclass)'
    --     INTO model_id;

    -- Perform acutal computation and output model
    EXECUTE '
        INSERT INTO ' || rel_output || '
        SELECT result
        FROM (
            SELECT MADLIB_SCHEMA.internal_ridge_newton_result(
                MADLIB_SCHEMA.ridge_newton_step(
                    (' || text_src || '.' || col_ind_var || ')::FLOAT8[],
                    (' || text_src || '.' || col_dep_var || ')::FLOAT8, 
                    (NULL)::FLOAT8[],
                    (' || dimension || ')::INT2,
                    (' || lambda || ')::FLOAT8
                    )
                ) AS result
            FROM ' || text_src || ' 
            ) subq';

    -- return description
/*    RAISE NOTICE $notice$
Finished ridge regression using Newton's method
 * table : % (%, %)
Results:
 * view : SELECT * FROM % WHERE id = %$notice$,
    rel_source, col_ind_var, col_dep_var, rel_output, model_id;
  */
    --RETURN model_id;
    --tbl_output_metricEXECUTE 'SELECT coefficients FROM '|| rel_output ||' WHERE id = '|| model_id INTO coef;
    --RETURN coef;
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION MADLIB_SCHEMA.ridge_newton_train(
    rel_source      VARCHAR,
    col_ind_var     VARCHAR,
    col_dep_var     VARCHAR,
    rel_output      VARCHAR,  
    dimension       INTEGER)
RETURNS VOID AS $$
BEGIN
    PERFORM MADLIB_SCHEMA.ridge_newton_train($1, $2, $3, $4, $5, 0.1);
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION MADLIB_SCHEMA.ridge_newton_train(
    rel_source      VARCHAR,
    col_ind_var     VARCHAR,
    col_dep_var     VARCHAR,
    rel_output      VARCHAR)
RETURNS VOID AS $$
DECLARE
    dimension INTEGER;
BEGIN
    EXECUTE '
        SELECT max(array_upper(' || col_ind_var || ', 1))
        FROM ' || rel_source
        INTO dimension;

    PERFORM MADLIB_SCHEMA.ridge_newton_train($1, $2, $3, $4, dimension);
END;
$$ LANGUAGE plpgsql VOLATILE;

/**
 * @brief Prediction (real value) using learned coefficients for a given example.
 *
 * @param coefficients  Weight vector (hyperplane, classifier)
 * @param ind_var  Features (independent variables)
 *
 */
CREATE FUNCTION MADLIB_SCHEMA.__ridge_newton_predict(
    coefficients    DOUBLE PRECISION[],
    ind_var         DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION
AS 'MODULE_PATHNAME', 'ridge_newton_predict'
LANGUAGE C IMMUTABLE STRICT;

-- predict multiple data points given in a table
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.ridge_newton_predict(
    tbl_model       VARCHAR,
    tbl_new_data    VARCHAR,
    ind_var         VARCHAR,
    id_var          VARCHAR,    -- ID column
    tbl_prediction  VARCHAR
) RETURNS VOID AS $$
BEGIN
    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_prediction ||';
        CREATE TABLE '|| tbl_prediction ||' AS
            SELECT
                '|| tbl_new_data ||'.'|| id_var ||' AS id,
                MADLIB_SCHEMA.__ridge_newton_predict(
                    coefficients,
                    '|| tbl_new_data ||'.'|| ind_var ||') AS prediction
            FROM
                '|| tbl_new_data ||',
                '|| tbl_model;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- compare the prediction and actual values
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.ridge_newton_error(
    tbl_prediction  VARCHAR,    -- predicted values
    tbl_actual      VARCHAR,
    id_actual       VARCHAR,
    values_actual   VARCHAR,
    tbl_error       VARCHAR
) RETURNS VOID AS $$
DECLARE
    error           DOUBLE PRECISION;
BEGIN
    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_error ||';
        CREATE TABLE '|| tbl_error ||' AS
        SELECT
            avg(('|| tbl_prediction ||'.prediction - '|| tbl_actual ||'.'|| values_actual ||')^2) as mean_squared_error
        FROM
            '|| tbl_prediction ||',
            '|| tbl_actual ||'
        WHERE
            '|| tbl_prediction ||'.id = '|| tbl_actual ||'.'|| id_actual;
END;
$$ LANGUAGE plpgsql VOLATILE;

----------------------------------------------------------------
----------------------------------------------------------------
-- compute the independent variables scales
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ridge_ind_var_scales(
    tbl_data        VARCHAR.
    col_ind_var     VARCHAR,
    dimension       INTEGER,
    tbl_scales      VARCHAR
) RETURNS VOID AS $$
DECLARE
    col_attr        VARCHAR := MADLIB_SCHEMA.__cv_unique_string(); -- columns for array
    col_val         VARCHAR := MADLIB_SCHEMA.__cv_unique_string(); -- column for values
BEGIN
    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_scales ||';
        CREATE TABLE '|| tbl_scales ||' AS
            SELECT
                '|| col_attr ||',
                avg('|| col_val ||') AS mean,
                stddev('|| col_val ||') AS std
            FROM (
                SELECT
                    generate_series(1, '|| dimension ||') as '|| col_attr ||',
                    unnest('|| col_ind_var ||') AS '|| col_val ||'
                FROM
                    '|| tbl_data ||'
                ) as foo
            GROUP BY '|| col_attr;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- compute the dependent variable scale
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ridge_dep_var_scale(
    tbl_data        VARCHAR.
    col_dep_var     VARCHAR,
    tbl_scale       VARCHAR     -- scale including mean and std
) RETURNS VOID AS $$
BEGIN
    EXECUTE '
        DROP TABLE IF EXISTS '|| tbl_scale ||';
        CREATE TABLE '|| tbl_scale ||' AS
            SELECT
                avg('|| col_dep_var ||') AS dep_avg,
                stddev('|| col_dep_var ||') AS dep_std
            FROM
                '|| tbl_data;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- normalize both the independent data and dependent data
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__ridge_normalize_data(
    tbl_data        VARCHAR,    -- original data
    col_ind_var     VARCHAR,    -- independent variables column 
    dimension       INTEGER,    -- length of independent variable array
    col_dep_var     VARCHAR,    -- dependent variable column
    tbl_ind_scales  VARCHAR,    -- independent variables scales array
    tbl_dep_scale   VARCHAR,    -- dependent variable scale 
    tbl_data_scaled VARCHAR     -- scaled data
) RETURNS VOID AS $$
BEGIN

END;
$$ LANGUAGE plpgsql VOLATILE;

-- column standard deviation
