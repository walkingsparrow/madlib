import plpy
from utilities.validate_args import __is_tbl_exists
from utilities.validate_args import __is_tbl_has_rows as _tbl_has_rows

class Summarizer:
    def __init__(self, schema_madlib, source_table, output_table,
                    target_cols , grouping_cols, distinctify,
                    ntileify, ntile_array=None, how_many_mfv=10):
        self._schema_madlib = schema_madlib
        self._source_table = source_table
        self._output_table = output_table
        self._grouping_cols = grouping_cols
        self._target_cols = target_cols
        self._distinctify = distinctify
        self._ntileify = ntileify
        self._ntile_array = ntile_array
        self._tableoid = None
        self._columns = None
        self._column_names = None
        self.how_many_mfv = how_many_mfv

    def _get_columns(self):
        self._columns = plpy.execute("""
              SELECT attname, typname, attnum
              FROM pg_attribute a join pg_type t on (a.atttypid=t.oid)
              WHERE attrelid = {tableoid}::regclass and attnum > 0 and not attisdropped
              ORDER BY attnum
              """.format(tableoid=self._tableoid))

        self._column_names = []
        for col in self._columns:
            self._column_names.append(col['attname'])

    # -----------------------------------------------------------------------
    # Argument validation functions
    # -----------------------------------------------------------------------
    def _validate_table_names(self):
        """
            Validate the required arguments for the summary function
        """
        if (self._source_table is None or self._source_table.strip() == ''):
            plpy.error("""
                Summary -- Invalid parameter: Source table name should be a
                non-empty string""")

        if self._output_table is None or self._output_table.strip() == '':
            plpy.error("""
                Summary -- Invalid parameter: Output table name should be a
                non-empty string""")
        try:
            self._tableoid = plpy.execute("""
              SELECT '{source_table}'::regclass::oid
              """.format(source_table=self._source_table))[0]['oid']
        except:
            plpy.error("""
                Summary -- table '{source_table}' does not
                exist""".format(source_table=self._source_table))

        rowcount = plpy.execute("""
            SELECT count(*) FROM {source_table}""".format(
                source_table=self._source_table))[0]['count']
        if rowcount == 0:
            plpy.error("""
                Summary -- table '{source_table}' is empty""".format(
                source_table=self._source_table))

    def _validate_grouping_cols(self):
        non_exist_cols = []
        for col in self._grouping_cols:
            if col is not None and col not in self._column_names:
                non_exist_cols.append(col)
        if len(non_exist_cols) > 0:
            plpy.error("""
                Summary -- Non-existing paramter: column(s) {0} do not
                exist""".format(str(non_exist_cols)[1:-1]))

    def _validate_target_cols(self):
        non_exist_cols = []
        if self._target_cols is None:
            return
        for col in self._target_cols:
            if col not in self._column_names:
                non_exist_cols.append(col)
        if len(non_exist_cols) > 0:
            plpy.error("""
                Summary -- Non-existing paramter: column(s) {0} do not
                exist""".format(str(non_exist_cols)[1:-1]))

    def _validate_ntile_array(self):
        if self._ntile_array is not None:
            for ntile in self._ntile_array:
                if ntile < 0 or ntile > 1.0:
                    plpy.error("""
                        Invalid parameter: values in ntile_array should be in
                        the range of [0.0, 1.0]""")

    def _adjust_cols(self):
        tcols = self._target_cols
        if tcols is None:
            tcols = self._column_names

        # if #tcols == 1, then it should not appear in the grouping_cols
        if len(tcols) == 1 and tcols[0] in self._grouping_cols:
            self._grouping_cols.remove(tcols[0])

        if self._target_cols is not None:
            self._columns = filter(
                lambda r: r['attname'] in self._target_cols, self._columns)

    def _validate_paras(self):
        """
        Validate all parameters in the class
        """
        self._validate_table_names()
        self._get_columns()
        self._validate_target_cols()
        self._validate_grouping_cols()
        self._adjust_cols()
        self._validate_ntile_array()
        if self.how_many_mfv < 0:
            plpy.error("""
                Summary -- Invalid parameter: number of most frequent values
                should be positive""")
    # ----- End of argument validation functions -----------------------------

    def _build_subquery(self, group_var):
        args = {'source_table': self._source_table}
        # Exclude the grouping_cols variable from the list of columns to report statistics on
        cols = filter(lambda x: x['attname'] != group_var, self._columns)

        if group_var is not None:
            args['group_value']  = "{schema_madlib}.__to_char(%s)" % group_var
            args['group_var']  = "'%s'" % group_var
            args['group_expr'] = "\n       GROUP BY %s" % group_var
        else:
            args['group_value'] = "NULL"
            args['group_var']  = "NULL"
            args['group_expr'] = ""

        args['column_names'] = ','.join(["'%s'" % c['attname'] for c in cols])
        args['column_types'] = ','.join(["'%s'" % c['typname'] for c in cols])
        args['column_number'] = ','.join([str(c['attnum']) for c in cols])
        if self._distinctify is 'Estimated':
            args['distinct_columns'] = ','.join(["{schema_madlib}.fmsketch_dcount(%s)" % c['attname'] for c in cols])
        elif self._distinctify is 'Exact':
            args['distinct_columns'] = ','.join(["count(distinct %s)" % c['attname'] for c in cols])
        else:
            args['distinct_columns'] = ','.join(["NULL" for c in cols])
        #args['missing_columns'] = ','.join(["count(%s) filter (where %s is null)" % (c['attname'],c['attname']) for c in cols])
        #args['blank_columns'] = ','.join(["count(%s) filter (where %s similar to E'^\\\\W*$')" % (c['attname'],c['attname']) for c in cols])
        args['missing_columns'] = ','.join(["sum(case when %s is null then 1 else 0 end)" % (c['attname']) for c in cols])
        args['blank_columns'] = ','.join(["sum(case when %s similar to E'\\\\W*' then 1 else 0 end)" % (c['attname']) if c['typname'] in ('varchar','bpchar','text') else 'NULL' for c in cols])

        def numeric_type(operator, datatype):
            if datatype['typname'] in ('int2','int4','int8','float4','float8','numeric'):
                return '%s(%s)' % (operator, datatype['attname'])
            return "NULL"

        def minmax_type(minmax, c):
            if c['typname'] in ('int2','int4','int8','float4','float8','numeric'):
                return '%s(%s)' % (minmax, c['attname'])
            if c['typname'] in ('varchar','bpchar','text'):
                return "%s(length(%s))" % (minmax, c['attname'])
            return "NULL"

        def quant_type(ntile, c):
            if self._ntileify is 'Exact':
                if c['typname'] in ('int2','int4','int8','float4','float8','numeric'):
                    return "percentile_cont(%s) WITHIN GROUP (ORDER BY %s)" % (ntile, c['attname'])
            if self._ntileify is 'Estimated':
                return "NULL"  # NOT YET IMPLEMENTED
            return "NULL"

        args['mean_columns'] = ','.join([numeric_type('avg', c) for c in cols])
        args['var_columns'] = ','.join([numeric_type('variance',c) for c in cols])
        args['min_columns'] = ','.join([minmax_type('min',c) for c in cols])
        args['q1_columns'] = ','.join([quant_type('0.25',c) for c in cols])
        args['q2_columns'] = ','.join([quant_type('0.50',c) for c in cols])
        args['q3_columns'] = ','.join([quant_type('0.75',c) for c in cols])
        args['max_columns'] = ','.join([minmax_type('max',c) for c in cols])

        args['ntile_columns'] = "array_to_string(array[NULL], ',')"
        if self._ntile_array is not None:
            args['ntile_columns'] = ",".join([
                "array_to_string(array[" +
                ",".join([quant_type(ntile, c) for ntile in self._ntile_array])
                + "], ',')" for c in cols])

        return """
                SELECT
                    {group_var}::text as group_by,
                    {group_value}::text as group_by_value,
                    array[{column_names}]::text[] as target_column,
                    array[{column_types}]::text[] as datatype,
                    array[{column_number}]::integer[] as colnum,
                    count(*)::bigint as rowcount,
                    array[{mean_columns}]::float8[] as mean,
                    array[{var_columns}]::float8[] as variance,
                    array[{distinct_columns}]::bigint[] as distinct_values,
                    array[{missing_columns}]::bigint[] as missing_values,
                    array[{blank_columns}]::bigint[] as blank_values,
                    array[{min_columns}]::float8[] as min,
                    array[{q1_columns}]::float8[] as first_quartile,
                    array[{q2_columns}]::float8[] as median,
                    array[{q3_columns}]::float8[] as third_quartile,
                    array[{ntile_columns}]::text[] as ntiles,
                    array[{max_columns}]::float8[] as max
                FROM {source_table}{group_expr}
         """.format(**args).format(schema_madlib=self._schema_madlib)

    def _build_query(self):
        subquery = """  UNION ALL""".join(
            [self._build_subquery(g) for g in self._grouping_cols])
        plpy.execute("""
            DROP TABLE IF EXISTS {output_table};""".format(
            output_table=self._output_table))
        query = """
            CREATE TABLE {output_table} AS
            SELECT
                    group_by,
                    group_by_value,
                    target_column,
                    datatype,
                    colnum,
                    rowcount,
                    distinct_values,
                    missing_values,
                    blank_values,
                    distinct_values::float8 / rowcount as fraction_distinct_values,
                    missing_values::float8 / rowcount as fraction_missing_values,
                    blank_values::float8 / rowcount as fraction_blank_values,
                    mean,
                    variance,
                    min,
                    first_quartile,
                    median,
                    third_quartile,
                    ntiles::float8[],
                    max
            FROM
            (
                SELECT
                    group_by,
                    group_by_value,
                    target_column,
                    datatype,
                    colnum,
                    rowcount,
                    distinct_values,
                    missing_values,
                    blank_values,
                    distinct_values::float8 / rowcount as fraction_distinct_values,
                    missing_values::float8 / rowcount as fraction_missing_values,
                    blank_values::float8 / rowcount as fraction_blank_values,
                    mean,
                    variance,
                    min,
                    first_quartile,
                    median,
                    third_quartile,
                    ntiles,
                    max
                FROM
                (
                    SELECT
                        group_by,
                        group_by_value,
                        unnest(target_column) AS target_column,
                        unnest(datatype) AS datatype,
                        unnest(colnum) AS colnum,
                        rowcount,
                        unnest(distinct_values) as distinct_values,
                        unnest(missing_values) as missing_values,
                        unnest(blank_values) as blank_values,
                        unnest(mean) as mean,
                        unnest(variance) as variance,
                        unnest(min) as min,
                        unnest(first_quartile) as first_quartile,
                        unnest(median) as median,
                        unnest(third_quartile) as third_quartile,
                        string_to_array(unnest(ntiles), ',') as ntiles,
                        unnest(max) as max
                    FROM ({subquery}) q1
                ) q2
            ) q3
            m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (group_by)')
        """.format(subquery=subquery, output_table = self._output_table)
        return query


    def run(self):
        self._validate_paras()
        plpy.execute(self._build_query())
