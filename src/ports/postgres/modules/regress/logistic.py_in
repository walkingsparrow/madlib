# coding=utf-8

"""
@file logistic.py_in

@brief Logistic Regression: Driver functions

@namespace logistic

@brief Logistic Regression: Driver functions
"""

import plpy

def __runIterativeAlg(stateType, initialState, source, updateExpr,
    terminateExpr, maxNumIterations, cyclesPerIteration = 1):
    """
    Driver for an iterative algorithm
    
    A general driver function for most iterative algorithms: The state between
    iterations is kept in a variable of type <tt>stateType</tt>, which is
    initialized with <tt><em>initialState</em></tt>. During each iteration, the
    SQL statement <tt>updateSQL</tt> is executed in the database. Afterwards,
    the SQL query <tt>updateSQL</tt> decides whether the algorithm terminates.
    
    @param stateType SQL type of the state between iterations
    @param initialState The initial value of the SQL state variable
    @param source The source relation
    @param updateExpr SQL expression that returns the new state of type
        <tt>stateType</tt>. The expression may use the replacement fields
        <tt>"{state}"</tt>, <tt>"{iteration}"</tt>, and
        <tt>"{sourceAlias}"</tt>. Source alias is an alias for the source
        relation <tt><em>source</em></tt>.
    @param terminateExpr SQL expression that returns whether the algorithm should
        terminate. The expression may use the replacement fields
        <tt>"{oldState}"</tt>, <tt>"{newState}"</tt>, and
        <tt>"{iteration}"</tt>. It must return a BOOLEAN value.
    @param maxNumIterations Maximum number of iterations. Algorithm will then
        terminate even when <tt>terminateExpr</tt> does not evaluate to \c true
    @param cyclesPerIteration Number of aggregate function calls per iteration.
    """
    
    updateSQL = """
        SELECT
            {{iteration}} AS iter,
            {updateExpr} AS state
        FROM
            {source} AS src
        """.format(updateExpr = updateExpr, source = source)
    updateSQL = updateSQL.format(iteration = '$1', state = '$2')
    terminateSQL = """
        SELECT {terminateExpr} AS should_terminate
        """.format(terminateExpr = terminateExpr)
    terminateSQL = terminateSQL.format(newState = '$1', oldState = '$2')
    checkForNullStateSQL = """SELECT {state} IS NULL AS should_terminate"""
    checkForNullStateSQL = checkForNullStateSQL.format(state = '$1')

    plan_update = plpy.prepare(
        updateSQL, [ 'INTEGER', 'FLOAT8[]' ])
    plan_terminatesql = plpy.prepare(
        terminateSQL, [ 'FLOAT8[]', 'FLOAT8[]' ])
    plan_checkfornullstate = plpy.prepare(
        checkForNullStateSQL, [ 'FLOAT8[]' ])

    oldMsgLevel = plpy.execute("SELECT setting FROM pg_settings WHERE name='client_min_messages'"
        )[0]['setting']
    plpy.execute("""
        SET client_min_messages = error;
        DROP TABLE IF EXISTS _madlib_iterative_alg;
        CREATE TEMPORARY TABLE _madlib_iterative_alg (
            --_madlib_iteration INTEGER PRIMARY KEY,
            _madlib_iteration INTEGER,
            _madlib_state {stateType}
        );
        SET client_min_messages = {oldMsgLevel};
        """.format(stateType = stateType, oldMsgLevel = oldMsgLevel))

    iteration = 0
    state_old = plpy.execute("""
        SELECT {iteration} AS iter, {initialState} AS state
        """.format(iteration = iteration, initialState = 'NULL'))
    while True:
        iteration = iteration + 1
        state_new = plpy.execute(plan_update, [ iteration, state_old[0]['state'] ])

        if plpy.execute(
            plan_checkfornullstate,
            [ state_new[0]['state'] ])[0]['should_terminate'] or (
            iteration > cyclesPerIteration and (
            iteration >= cyclesPerIteration * maxNumIterations or
            plpy.execute(
                plan_terminatesql, 
                [ state_new[0]['state'], state_old[0]['state'] ])[0]['should_terminate'])):
            plan_final = plpy.prepare(
                'insert into _madlib_iterative_alg values($1, $2)',
                [ 'INTEGER', 'FLOAT8[]' ])
            plpy.execute(
                plan_final, 
                [ state_new[0]['iter'], state_new[0]['state'] ])
            break
        state_old = state_new
    
    # Note: We do not drop the temporary table
    return iteration

def compute_logregr(schema_madlib, source, depColumn, indepColumn, optimizer,
    maxNumIterations, precision, **kwargs):
    """
    Compute logistic regression coefficients
    
    This method serves as an interface to different optimization algorithms.
    By default, iteratively reweighted least squares is used, but for data with
    a lot of columns the conjugate-gradient method might perform better.
    
    @param schema_madlib Name of the MADlib schema, properly escaped/quoted
    @param source Name of relation containing the training data
    @param depColumn Name of dependent column in training data (of type BOOLEAN)
    @param indepColumn Name of independent column in training data (of type
           DOUBLE PRECISION[])
    @param optimizer Name of the optimizer. 'newton' or 'irls': Iteratively
        reweighted least squares, 'cg': conjugate gradient or 'igd': 
        incremental gradient descent
    @param maxNumIterations Maximum number of iterations
    @param precision Terminate if two consecutive iterations have a difference 
           in the log-likelihood of less than <tt>precision</tt>. In other
           words, we terminate if the objective function value has converged.
           This convergence criterion can be disabled by specifying a negative
           value.
    @param kwargs We allow the caller to specify additional arguments (all of
           which will be ignored though). The purpose of this is to allow the
           caller to unpack a dictionary whose element set is a superset of 
           the required arguments by this function.
    
    @return array with coefficients in case of convergence, otherwise None
    """
    
    if maxNumIterations < 1:
        plpy.error("Number of iterations must be positive")
    
    if optimizer == 'newton':
        optimizer = 'irls'
    elif optimizer not in ['irls', 'cg', 'igd']:
        plpy.error("Unknown optimizer requested. Must be 'newton'/'irls', "
            "'cg', or 'igd'")
    
    return __runIterativeAlg(
        stateType = "FLOAT8[]",
        initialState = "NULL",
        source = source,
        updateExpr = """
            {schema_madlib}.logregr_{optimizer}_step(
                ({depColumn})::BOOLEAN,
                ({indepColumn})::FLOAT8[],
                {{state}}
            )
            """.format(
                schema_madlib = schema_madlib,
                depColumn = depColumn,
                indepColumn = indepColumn,
                optimizer = optimizer),
        terminateExpr = """
            {schema_madlib}.internal_logregr_{optimizer}_step_distance(
                {{newState}}, {{oldState}}
            ) < {precision}
            """.format(
                schema_madlib = schema_madlib,
                optimizer = optimizer,
                precision = precision),
        maxNumIterations = maxNumIterations)
